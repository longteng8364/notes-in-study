<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 
        Set:
            ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复。
            Set本身是一个构造函数，用来生成Set数据结构。
                const s = new Set();
            Set函数还可以接受数组和类数组作为参数。

            向Set加入值的时候，不会发生类型转换，所以5和“5”是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做"Same-value-zero equality",它类似于精确相等运算符（===），主要的区别是NaN等于自身，而（===）认为NaN不等于自身。另外，两个对象永远是不想等的。

        Set实例的属性和方法：
            Set结构的实例有如下属性：
                -Set.prototype.constructor:构造函数，默认就是Set函数。
                -Set.prototype.size:返回Set实例的成员总数。
            Set实例的方法分为两大类：操作方法和遍历方法，
            四个操作方法：
                -add(value):添加某个值，返回Set结构本身。
                -delete(value):删除某个值，返回一个布尔值，表示删除是否成功。
                -has(value)：返回一个布尔值，表示该值是否为Set结构的成员。
                -clear():清除所有成员，没有返回值。

                小栗子：
                    s.add(1).add(2).add(2);//因为add函数返回Set结构本身，所以可以连续调用
                    s.size; // 2
                    s.has(1); //true
                    s.has(2); //true
                    s.has(3); //false
                    s.delete(1); 
            Array.from()可以将Set结构转为数组，这样数组去重的另一种方法就来了：
                function dedupe(array){
                    return Array.from(new Set(array));
                }
                dedupe([1,3,3,4,2,2,1]); // [1,3,4,2]

            四个遍历方法：
                -keys():返回键名的遍历器
                -values():返回键值的遍历器
                -entries():返回键值对的遍历器
                -forEach()：使用回调函数遍历每个成员
            由于Set结构没有键名，只有键值（或者说键名的键值是同一个值），所以keys方法和values方法的行为完全一致。而entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相同。
            Set结构的实例默认可以遍历，它的默认遍历器生成函数就是它的values方法，这意味着，可以省略values方法，直接用for...of循环遍历Set。

            Set结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。

            扩展运算符内部使用for...of循环，所以扩展运算符与Set结构相结合，就可以数组去重：
                let arr = [1,1,2,2,3,4];
                let unique = [...new Set(arr)];
                //[1,2,3,4]
            而且数组的map和filter方法也可以间接用于Set结构：
            例子：
                let a = new Set([1,2,3]);
                let b = new Set([4,3,2]);
                //并集：
                let union = new Set([...a, ...b]); // Set{1,2,3,4}
                //交集：
                let intersect = new Set([...a].filter(x => b.has(x))); // Set{2,3}
                //差集：
                let difference = new Set([...a].filter(x => !b.has(x)));


            需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用
            Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。


            WeakSet:
                WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。
                WeakSet结构与Set结构类似，也是不重复的值的集合。但是，它与Set有两个区别，首先，WeakSet的成员只能是对象，而不能是其他类型的值。其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用。所以WeakSet的成员是不适合引用的，因为它会随时消失。

                WeakSet结构有以下三个方法：
                    -WeakSet.prototype.add(value):向WeakSet实例添加一个新成员。
                    -WeakSet.prototype.delete(value):清除WeakSet实例的指定成员。
                    -WeakSet.prototype.has(value):返回一个布尔值，表示某个值是否在WeakSet实例中。
                
                WeakSet没有size属性，没有办法遍历它的成员，所以就没有forEach方法；




     -->
</body>
</html>